/*
  This file is part of KDDockWidgets.

  Copyright (C) 2018-2020 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com
  Author: Sérgio Martins <sergio.martins@kdab.com>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef KD_MULTISPLITTER_ANCHOR_P_H
#define KD_MULTISPLITTER_ANCHOR_P_H


QT_BEGIN_NAMESPACE
class QRubberBand;
QT_END_NAMESPACE

namespace KDDockWidgets {


class DOCKS_EXPORT_FOR_UNIT_TESTS Anchor : public QObject // clazy:exclude=ctor-missing-parent-argument
{

public:

    static Anchor* deserialize(const LayoutSaver::Anchor &, MultiSplitterLayout *layout);
    LayoutSaver::Anchor serialize() const;

    void ensureBounded();

    /**
     * @brief Sets the new layout. Called when we're dropping a source layout into a target one.
     * The target one will steal the separators of the source one.
     */
    void setLayout(MultiSplitterLayout *);

    /**
     * @brief Returns whether this Anchor should follow another one. That happens if one of it's side is empty or only has placeholders
     * Also, it can't be a static anchor.
     */
    bool shouldFollow() const { return !isStatic() && (onlyHasPlaceholderItems(Side1) || onlyHasPlaceholderItems(Side2)); }

    bool isStaticOrFollowsStatic() const;


    void setPositionOffset(int);
    bool isBeingDragged() const;

    int cumulativeMinLength(Anchor::Side side) const;

    /**
     * @brief Makes this separator follow another one. This one will be made invisible.
     * Used when the item in the layout is just a placeholder remembering a previous dock widget position.
     * Pass nullptr do make it not follow and visible again.
     */
    void setFollowee(Anchor *);

    /**
     * @brief getter for the followee
     */
    Anchor *followee() const { return m_followee; }

    /**
     * @brief Returns the list of anchors following this one.
     */
    const List followers() const;

    /**
     * @brief Returns the last followee in the chain.
     */
    Anchor *endFollowee() const;

    /**
     * @brief Recursively looks for an anchor in the whole layout but only looking at side @p side
     *
     * This allows us to know if there's an anchor on the top or left of us (side1) or right or bottom
     * (side2), in the whole layout.
     *
     * Returns false if @p anchor is nullptr
     */
    bool findAnchor(Anchor *anchor, Side side) const;

    /**
     * @brief Returns the nearest Anchor with non-placeholder items on side @p side
     * If nothing is found then returns the static anchor on that side
     */
    Anchor *findNearestAnchorWithItems(Side side) const;

    static Anchor::Side oppositeSide(Side side);
    void onFolloweePositionChanged(int pos);

    void onMousePress();
    void onMouseReleased();
    void onMouseMoved(QPoint pt);
    void onWidgetMoved(int p);


    ///@brief Returns whether we're dragging a separator. Can be useful for the app to stop other work while we're not in the final size
    static bool isResizing();

private:
    struct CumulativeMin {
        int minLength;
        int numItems;
        CumulativeMin& operator+=(CumulativeMin other) {
            minLength += other.minLength;
            numItems += other.numItems;
            return *this;
        }
    };
    CumulativeMin cumulativeMinLength_recursive(Anchor::Side side) const;

    void setLazyPosition(int);

Q_SIGNALS:
    void positionChanged(int pos);
    void itemsChanged(Anchor::Side);
    void fromChanged();
    void toChanged();
    void debug_itemNamesChanged();
    void followeeChanged();
    void thicknessChanged();

public:
    int position(QPoint) const;

    // Only set when anchor is moved through mouse. Side1 if going towards left or top, Side2 otherwise.
    Side m_lastMoveDirection = Side_None;

    bool m_showingSide1Rubberband = false;
    bool m_showingSide2Rubberband = false;

    static bool s_isResizing;

    QMetaObject::Connection m_followeeDestroyedConnection;
    const bool m_lazyResize;
    int m_lazyPosition = 0;
    QRubberBand *const m_lazyResizeRubberBand;
};

}

Q_DECLARE_METATYPE(KDDockWidgets::ItemList)
Q_DECLARE_METATYPE(KDDockWidgets::Item*)

#endif
